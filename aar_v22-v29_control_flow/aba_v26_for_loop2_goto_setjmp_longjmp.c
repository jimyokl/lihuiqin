/*
       "函数调用栈" 在英语中通常翻译为 "call stack"。它指的是在程序执行过程中，记录函数调用和返回的栈结构。
   当一个函数被调用时，它会被压入栈中，函数执行完毕后，从栈中弹出。

   非局部跳转（non-local jump），即跨越函数调用栈的跳转。

       “跨越函数调用栈的跳转” 通常指的是在程序执行过程中，从一个函数的执行跳到另一个函数（或者程序的某个特定位置），
   而这个过程不遵循常规的函数调用返回机制。
   
   通常涉及一些底层操作，比如修改函数调用栈的指针，导致程序的控制流跳过某些正常的调用顺序。

       函数调用栈用于保存函数调用的返回地址、局部变量、参数等。当函数调用完成时，返回地址指示程序应该从哪里继续执行。
    如果进行“跨越函数调用栈的跳转”，通常会绕过一些正常的控制流机制，可能是通过：

    1. 长跳（Long Jump）：这可以通过类似 `setjmp` 和 `longjmp`（在C语言中）这样的机制来实现，
       允许从某个函数的执行点跳到另一个地方。通常用于异常处理、协程切换等场景。

    2. 栈破坏或栈溢出：如果通过不安全的操作（例如缓冲区溢出），修改栈中的返回地址，
       就可以实现从一个函数直接跳转到另一个地方，这种行为可能导致程序崩溃或者被攻击者利用进行恶意操作。

    3. 回调和函数指针：在一些高级语言中，回调函数或者通过函数指针的方式可以让程序在运行时决定跳转到哪个函数执行，
       虽然这种方式是合法的，但从“调用栈”的角度看，它是一种“跨越栈”的跳转。

       这个概念在很多场景下涉及底层的控制流操作，通常不是一种常规的函数调用方式，可能带来复杂的调试和维护问题。

    setjmp + longjmp 组合能打破函数调用栈的“正常流程”，在任何地方恢复到之前保存的执行点:
    常见应用： 异常处理（类似 try/catch）
              错误恢复机制
              协程或任务切换
*/
/*
  注意事项：
    - `setjmp`和`longjmp`可以用来处理异常情况，但是它们改变了正常的控制流，所以使用时需要小心。
    - 使用`longjmp`时，应该确保跳转后的状态是有效的，否则可能会导致未定义行为。

    这种机制类似于异常处理，但它是手动管理的，而且只适用于相对简单的情况。
*/

#include <stdio.h>
#include <setjmp.h>
#include <stdlib.h>

// 跨函数跳转（比如从一个函数直接跳到另一个函数），通常称为 “function jump
// 更广泛的跳转（比如在不同模块或程序的函数之间跳转），也可以用 “cross-function call”, cross-function jump(跨函数跳转)

jmp_buf env; // jmp_buf：保存环境信息（如寄存器状态、栈指针等），供之后 longjmp 使用

void funcB() 
{
    printf("In funcB, jumping back to funcA\n");

    // longjmp(env, 1); 会使程序跳回到之前执行 setjmp(env) 的那一行，并使 setjmp(env) 返回 1，
    // 这样程序跳过 if 的代码块，执行 else：
    longjmp(env, 1);  // 跳回到setjmp，void longjmp(jmp_buf env, int val)
}

void funcA() 
{
    if (setjmp(env) == 0)                           //第一次调用setjmp，返回值为0，int setjmp(jmp_buf env);
    {
        printf("In funcA, calling funcB\n");
        funcB();                                    //调用 funcB，跳回到 funcA
    } else {
        printf("Back in funcA after longjmp\n");    // longjmp 调用后返回的值
    }
}
int main() 
{
    funcA();  // 调用 funcA
    exit(0);
}